# Узнай больше о GraphQL

## Определение объектов

Файл `schema.graphql` определяет различные схемы GraphQL. Из-за того, как работает язык запросов GraphQL, схема файлов по сути диктует форму ваших данных из SubQuery. There are libraries to help you implement GraphQL in [many different languages](https://graphql.org/code/)

**Важно: При внесении каких-либо изменений в файл, убедитесь, что вы регенерируете директорию типов, используя следующую команду `yarn codegen`**

### Сущности
Каждая сущность должна определить свои требуемые поля `id` с типом `ID!`. Он используется в качестве первичного ключа и уникален между всеми сущностями одного типа.

Поля, не допускающие значения NULL, в сущности обозначены `!`. Пожалуйста, смотрите пример ниже:

```graphql
напечатайте Пример @entity {
  id: ID! поле # id всегда необходимо заполнять и оно должно выглядеть следующим образом
  name: String! # Это обязательное поле для заполнения
  address: String # Это необязательное поле
}
```

### Поддерживаемые скаляры и типы

В настоящее время мы поддерживаем следующие скалярные типы:
- `ID`
- `Int`
- `Строка`
- `BigInt`
- `Дата`
- `Логический`
- `<EntityName>` для вложенных сущностей связей вы можете использовать определенное имя сущности в качестве одного из полей. Пожалуйста, смотрите в [Entity Relationships](#entity-relationships).
- `JSON` может также хранить структурированные данные, см. [JSON type](#json-type)

## Индексирование с помощью не первичного ключа

Чтобы улучшить производительность поисковых запросов, индексируйте выбранные области просто внедрив аннотацию `@index` в поле непервичного ключа.

Тем не менее, мы не позволяем пользователям добавлять аннотации `@index` к любому объекту [JSON](#json-type). По умолчанию, индексы автоматически добавляются к внешним ключам и для полей JSON в базе данных, но только для повышения производительности службы запросов.

Вот пример.

```graphql
тип пользователя @entity {
  id: ID!
  name: String! @index(unique: true) # уникальное может быть установлено в true или false
  title: Title! # Индексы автоматически добавляются в поле внешнего ключа 
}

тип Title @entity {
  id: ID!  
  name: String! @index(unique:true)
}
```
Предполагая, что мы знали имя этого пользователя, но мы не знаем его точное значение id, вместо того, чтобы извлекать всех пользователей, а затем фильтровать их по имени, мы можем добавить `@index` за полем имени. Это делает поиск гораздо более быстрее, и мы можем дополнительно пройти `unique: true` для обеспечения уникальности.

**Если поле не уникальное, то максимальный размер набора результатов равен 100**

Когда выполняется генерация кода, автоматически создастся `getByName` в соответствии с моделью `User` </code>, и внешний ключ `title` создаст метод `getByTitleId</0>, к которым оба могут быть напрямую доступны в функции сопоставления.

```sql
/* Prepare a record for title entity */
INSERT INTO titles (id, name) VALUES ('id_1', 'Captain')
```

```typescript
etByName('Jack Sparrow');

const captainTitle = await Title.getByName('Captain');

const pirateLords = await User.getByTitleId(captainTitle.id); // Список всех капитанов
```

## Связи субъектов

Сущность часто имеет вложенные отношения с другими субъектами. Установка значения поля на другое имя объекта определит связь между этими двумя объектами по умолчанию.

Различные отношения объектов (один-на-один, и многие) могут быть настроены с помощью приведенных ниже примеров.

### Индивидуальные отношения

Отношения «один к одному» используются по умолчанию, когда только один объект сопоставляется с другим.

Пример: паспорт будет принадлежать только одному человеку, и у человека есть только один паспорт (в данном примере):

```graphql
тип Person @entity {
  id: ID!
}

тип Passport @entity {
  id: ID!
  владелец: Человек!
}
```

или

```graphql
тип Person @entity {
  id: ID!
  паспорт: Passport!
}

тип Passport @entity {
  id: ID!
  владелец: Person!
}
```

### Отношения от одного до нескольких

Вы можете использовать квадратные скобки, чтобы указать, что тип поля включает несколько сущностей.

Пример: Человек может иметь несколько учетных записей.

```graphql
тип Person @entity {
  id: ID!
  аккаунты: [Account] 
}

тип аккаунта @entity {
  id: ID!
  публичный адрес: String!
}
```

### Отношения "многие ко многим"
Отношения «многие ко многим» могут быть достигнуты путем реализации объекта сопоставления для соединения двух других объектов.

Пример: каждый человек является частью нескольких групп (PersonGroup), а в группах есть несколько разных людей (PersonGroup).

```graphql
тип Person @entity {
  id: ID!
  name: String!
  группы: [PersonGroup]
}

тип PersonGroup @entity {
  id: ID!
  человек: Person!
  Группа: Group!
}

тип Group @entity {
  id: ID!
  name: String!
  persons: [PersonGroup]
}
```

Кроме того, можно создать соединение одной и той же сущности в нескольких полях средней сущности.

Например, учетная запись может иметь несколько переводов, и каждая передача имеет исходную и целевую учетные записи.

Это установит двусторонние отношения между двумя аккаунтами (от и до) через таблицу передачи.

```graphql
тип Account @entity {
  id: ID!
  публичный адрес: String!
}

тип Transfer @entity {
  id: ID!
  сумма: BigInt
  от: Account!
  to: Account!
}
```

### Обратные запросы

Чтобы разрешить обратный поиск объекта в отношении, присоедините `@dehibitedFrom` к полю и укажите на его поле обратного просмотра другого объекта.

Это создает виртуальное поле на объекте, который может быть запрошен.

Передача «от» учетной записи доступна из объекта аккаунта путем установки значения sentTransfer или receiveTransfer, полученного из соответствующих полей from или to.

```graphql
тип Account @entity {
  id: ID!
  публичный адрес: String!
  sentTransfers: [Transfer] @derivedFrom(field: "from")
  receivedTransfers: [Transfer] @derivedFrom(field: "to")
}

type Transfer @entity {
  id: ID!
  сумма: BigInt
  от: Account!
  от: Account!
}
```

## Тип JSON

Мы поддерживаем сохранение данных в формате JSON, что является быстрым способом хранения структурированных данных. Мы автоматически сгенерируем соответствующие интерфейсы JSON для запроса данных и сэкономим время для определения и управления сущностями.

Мы рекомендуем пользователям использовать тип JSON в следующих сценариях:
- Хранение структурированных данных в одном поле более управляемо, чем создание нескольких отдельных сущностей.
- Сохранение произвольных пользовательских настроек ключа / значения (где значение может быть логическим, текстовым или числовым, и вы не хотите иметь отдельные столбцы для разных типов данных)
- Схема является волатильной и часто меняется

### Определить директиву JSON
Определите свойство как тип JSON файла, добавив аннотацию `jsonField` в объекте. Это автоматически создаст интерфейсы для всех JSON объектов в вашем проекте в `types/interfaces.ts`, и вы можете получить доступ к ним в функции сопоставления.

В отличие от объекта, директивный jsonField объект не требует поля `id`. Объект JSON также способен соединиться с другими объектами JSON.

````graphql
тип AddressDetail @jsonField {
  улица: String!
  округ: String!
}

введите ContactCard @jsonField {
  телефон: String!
  адрес: AddressDetail # Вложенный JSON
}

тип User @entity {
  id: ID! 
  контакт: [ContactCard] # Сохраните список JSON объектов
}
````

### Запрос полей JSON

Недостатком использования файлов типа JSON является слабое влияние на эффективность запроса при фильтрации, поскольку каждый раз, когда выполняется текстовый поиск, он выполняется по всему объекту.

Тем не менее, влияние на нашу работу по поисковым запросам все еще приемлемо. Вот пример того, как использовать `contains` оператора в запросе GraphQL на JSON файл, чтобы найти пять первых пользователей, у которых есть номер телефона, содержащий '0064'.

```graphql
#Чтобы найти первых 5 пользователей телефоны которых содержат '0064'.

query{
  пользователь (
    первый: 5,
    filter: {
      contactCard: {
        содержит : [{ phone: "0064" }]
    }
}){
    nodes{
      id
      contactCard
    }
  }
}
```
